import rospy
from sensor_msgs.msg import CompressedImage
from nozzle_net.msg import NozzleStatus  # Custom message type
import cv2
import numpy as np
import onnxruntime
import torchvision.transforms as transforms
from PIL import Image
import yaml  # Import YAML module for configuration loading

class NozzleNet:
    def __init__(self):
        self.load_config()  # Load configuration settings
        # Initialize ONNX model
        self.model = onnxruntime.InferenceSession(self.config['model_path'])
        # Define image transformations
        self.transform = transforms.Compose([
            transforms.Resize((self.config['image_height'], self.config['image_width'])),
            transforms.Lambda(lambda x: transforms.functional.crop(x, self.config['crop_top'], self.config['crop_bottom'], self.config['image_width'], self.config['image_height'])),  # Adding crop transformation
            transforms.ToTensor(),
            transforms.Normalize(mean=self.config['mean'], std=self.config['std'])
        ])
        # Initialize ROS publisher
        self.publisher = rospy.Publisher('/nozzle_status', NozzleStatus, queue_size=10)
        self.latest_image = None  
        self.first_blocked_time = None  # Track the first time the nozzle is blocked
        self.is_last_blocked = False
        self.labels = ['check_nozzle', 'nozzle_blocked', 'nozzle_clear']
        rospy.Subscriber('/suction_camera/image_raw/compressed', CompressedImage, self.image_callback)

    def load_config(self):
        # Load configuration settings from YAML file
        with open('config/nozzle_config.yaml', 'r') as file:
            self.config = yaml.safe_load(file)

    def image_callback(self, data):
        # Callback function for image subscriber
        np_arr = np.frombuffer(data.data, np.uint8)
        image_np = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
        self.latest_image = image_np

    def process_latest_image(self):
        # Process the latest received image
        if self.latest_image is None:
            return
            
        # Convert image to PIL format
        image_pil = Image.fromarray(cv2.cvtColor(self.latest_image, cv2.COLOR_BGR2RGB))
        # Apply transformations
        transformed_img = self.transform(image_pil)
        transformed_img = transformed_img.unsqueeze(0)
        # Get input and output names from the model
        input_name = self.model.get_inputs()[0].name
        output_name = self.model.get_outputs()[0].name
        # Run inference on the model
        pred = self.model.run([output_name], {input_name: transformed_img.numpy()})[0]
        
        # Calculate duration blocked
        current_time = rospy.Time.now()
        if pred.argmax() == 1:
            if self.first_blocked_time is None:
                self.first_blocked_time = current_time
            self.is_last_blocked = True
        else:
            self.first_blocked_time = None
            self.is_last_blocked = False
        duration_blocked = 0.0
        if self.first_blocked_time is not None:
            duration_blocked = (current_time - self.first_blocked_time).to_sec()
        
        # Publish nozzle status
        nozzle_status = NozzleStatus()
        nozzle_status.blocked_probability = pred[0][1]
        nozzle_status.duration_blocked = duration_blocked
        nozzle_status.prediction = self.labels[pred.argmax()]
        self.publisher.publish(nozzle_status)

if __name__ == '__main__':
    rospy.init_node('nozzle_net')
    processor = NozzleNet()
    rate = rospy.Rate(10)  # Set the rate for the while loop
    while not rospy.is_shutdown():
        processor.process_latest_image()
        rate.sleep()
